package main

import (
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"
)

func main() {
	elementType := flag.String("type", "", "element type for the generated code")
	stackType := flag.String("name", "", "name of the stack type to generate")
	packageName := flag.String("package", "", "package name to include in generated code")
	fileSuffix := flag.String("filesuffix", "", "suffix to add after gen and before .go in the generated code")
	flag.Parse()

	if *elementType == "" {
		die("Missing element type. Specify one with -type.")
	}

	if *stackType == "" {
		*stackType = *elementType
		*stackType = strings.TrimPrefix(*stackType, "[]") + "Stack"
		*stackType = strings.Replace(*stackType, "{}", "", -1)
	}

	if *packageName == "" {
		*packageName = os.Getenv("GOPACKAGE")
	}

	if *packageName == "" {
		die("Missing package name. Specify one with -package or using the GOPACKAGE environment variable.")
	}

	tmpl := template.Must(template.New("stack").Parse(stackTemplate))
	f, err := os.Create(strings.ToLower(*stackType + "_gen" + *fileSuffix + ".go"))
	if err != nil {
		die("%v", err)
	}
	defer f.Close()
	if err := tmpl.Execute(f, map[string]string{
		"ElementType": *elementType,
		"StackType":   *stackType,
		"PackageName": *packageName,
		"FullCommand": strings.Join(os.Args, " "),
	}); err != nil {
		panic(err)
	}
}

func die(f string, args ...interface{}) {
	fmt.Printf(f+"\n", args...)
	os.Exit(1)
}

const stackTemplate = `// Code generated by {{.FullCommand}} ; DO NOT EDIT

package {{.PackageName}}

type {{.StackType}} struct {
	data []{{.ElementType}}
}

func (s *{{.StackType}}) Push(v {{.ElementType}}) {
	s.data = append(s.data, v)
}

func (s *{{.StackType}}) Pop() (v {{.ElementType}}, ok bool) {
	if len(s.data) == 0 {
		return v, false
	}
	top := len(s.data) - 1
	v = s.data[top]
	s.data = s.data[:top]
	return v, true
}

func (s *{{.StackType}}) Peek() (v {{.ElementType}}, ok bool) {
	if len(s.data) == 0 {
		return v, false
	}
	top := len(s.data) - 1
	v = s.data[top]
	return v, true
}

func (s *{{.StackType}}) Len() int {
	return len(s.data)
}

func (s *{{.StackType}}) Walk(f func({{.ElementType}})) {
	for _, v := range s.data {
		f(v)
	}
}

func (s *{{.StackType}}) Rotate() {
	if len(s.data) == 0 {
		return
	}

	top := len(s.data) - 1
	s.data = append(s.data[top:], s.data[:top]...)
}

func (s *{{.StackType}}) Unrotate() {
	if len(s.data) == 0 {
		return
	}

	bottom := 0
	s.data = append(s.data[bottom+1:], s.data[bottom])
}
`
